<!DOCTYPE html>
<html>
  <head>
    <title>Fluent UI docsite shell</title>
    <meta
      name="description"
      content="Docisite shell to handle multi-version support and redirects, should not be the end content for users"
    />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=fetch%2CURL"></script>
  </head>
  <body>
    <script>
      function fetchManifest() {
        return fetch('/manifest.json').then(res => res.json());
      }

      function getAvailableVersionsFromManifest(manifest) {
        const availabeVersions = Object.keys(manifest).reduce((versions, version) => {
          if (manifest[version]) {
            versions.push(version);
          }

          return versions;
        }, []);

        availabeVersionsInParts = availabeVersions.map(v => v.split('.'));
        sortVersionsDescending(availabeVersionsInParts);
        return availabeVersionsInParts.map(x => x.join('.'));
      }

      function setRedirectInSessionStorage(currentVersion, newVersion) {
        if (!sessionStorage.redirect) {
          return;
        }

        const url = new URL(sessionStorage.redirect);
        const newPath = url.pathname.replace(currentVersion, newVersion);
        url.pathname = newPath;
        sessionStorage.redirect = url.href;
      }

      function sortVersionsDescending(versions) {
        versions.sort((a, b) => {
          // we assume that the manifest contains all parts of semver (major/minor/patch)
          for (let i = 0; i < 3; i++) {
            if (parseInt(a[i]) > parseInt(b[i])) return -1;

            if (parseInt(a[i]) < parseInt(b[i])) return 1;
          }
          return 0;
        });
      }

      // If the version provided can't be found in the manifest we try to match it to the closest version
      // Only works based on partial match, if none of the semver parts match, simply return the latest available
      function findClosestVersion(version, availableVersions) {
        const parts = version.split('.');

        // invalid semver check
        if (parts.length > 3 || parts.some(part => isNaN(part))) {
          return availableVersions[0];
        }

        const availabeVersionsInParts = availableVersions.map(version => version.split('.'));
        let lastMatchedVersions = availabeVersionsInParts;

        let matched = false;
        let i = 0;
        while (i < parts.length) {
          const matchedVersions = lastMatchedVersions.filter(versionInParts => versionInParts[i] === parts[i]);
          if (matchedVersions.length) {
            lastMatchedVersions = matchedVersions;
          } else {
            matched = true;
          }

          i++;
        }

        if (!matched) {
          return availableVersions[0];
        }

        sortVersionsDescending(lastMatchedVersions);
        return lastMatchedVersions[0].join('.');
      }

      function redirectToDocsite(manifest) {
        const fluentuiDocsiteVersions = getAvailableVersionsFromManifest(manifest);

        let redirectVersion = undefined;
        if (sessionStorage.redirect) {
          redirectVersion = new URL(sessionStorage.redirect).pathname.split('/')[1];
        }

        if (fluentuiDocsiteVersions.indexOf(redirectVersion) > -1) {
          window.location.pathname = '/' + redirectVersion;
          return;
        }

        if (redirectVersion) {
          const closestVersion = findClosestVersion(redirectVersion, fluentuiDocsiteVersions);
          setRedirectInSessionStorage(redirectVersion, closestVersion);
          window.location.pathname = '/' + closestVersion;
          return;
        }

        window.location.pathname = '/' + fluentuiDocsiteVersions[0];
      }

      (function init() {
        fetchManifest().then(manifest => redirectToDocsite(manifest));
      })();
    </script>
  </body>
</html>
