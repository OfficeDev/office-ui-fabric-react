import { DEFINITION_LOOKUP_TABLE, HASH_LENGTH, RTL_CLASSNAME, SEQUENCE_PREFIX } from './constants';
import { hashString } from './runtime/utils/hashString';
import { MakeStylesMatchedDefinitions } from './types';

// Contains a mapping of previously resolved sequences of atomic classnames
const axResults: Record<string, string> = {};

const RTL_CLASSNAME_SIZE = RTL_CLASSNAME.length + 1;
const SEQUENCE_SIZE = SEQUENCE_PREFIX.length + HASH_LENGTH;

/**
 * Function can take any number of arguments, joins classes together and deduplicates atomic declarations generated by
 * `makeStyles()`. Handles scoped directional styles.
 *
 * Classnames can be of any length, this function can take both atomic declarations and class names.
 *
 * Input:
 * ```
 * // not real classes
 * ax('ltr', ['ui-button', 'displayflex', 'displaygrid'])
 * ax('rtl', ['ui-button', 'displayflex', 'displaygrid'])
 * ```
 *
 * Output:
 * ```
 * 'ui-button displaygrid'
 * 'rtl ui-button displaygrid'
 * ```
 */
export function ax(dir: 'ltr' | 'rtl', classNames: (string | false | undefined)[]): string {
  let resultClassName = '';
  // Is used as a cache key to avoid object merging
  let sequenceMatch = '';

  const sequenceMappings: MakeStylesMatchedDefinitions[] = [];

  for (let i = 0; i < classNames.length; i++) {
    const className = classNames[i];

    if (typeof className === 'string') {
      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets
      // without parsing each className in a string
      const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);

      if (sequenceIndex === -1) {
        resultClassName += className + ' ';
      } else {
        const sequenceId = className.slice(sequenceIndex, sequenceIndex + SEQUENCE_SIZE);
        const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];

        // Handles a case with mixed classnames, i.e. "ui-button ATOMIC_CLASSES"
        if (sequenceIndex > 0) {
          // "rtl" classname if present will be always first: both ax() & makeStyles() follow this rule
          const hasRTLPrefix = className.indexOf(`${RTL_CLASSNAME} `) === 0;

          resultClassName += className.slice(hasRTLPrefix ? RTL_CLASSNAME_SIZE : 0, sequenceIndex);
        }

        if (sequenceMapping) {
          sequenceMatch += sequenceId;
          sequenceMappings.push(sequenceMapping);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {
          // eslint-disable-next-line no-console
          console.error(
            `ax(): a passed string contains multiple identifiers of atomic classes (classes that start with "${SEQUENCE_PREFIX}"), it's possible that passed classes were concatenated in a wrong way. Source string: ${className}`,
          );
        }

        if (className.indexOf(`${RTL_CLASSNAME} `, 1) >= 1) {
          // eslint-disable-next-line no-console
          console.error(
            `ax(): a passed string contains multiple identifiers of RTL mode ("rtl" classes), it's possible that passed classes were concatenated in a wrong way. Source string: ${className}`,
          );
        }
      }
    }
  }

  if (sequenceMatch === '') {
    // .slice() there and later allows to avoid trailing space
    return resultClassName.slice(0, -1);
  }

  const axResult = axResults[sequenceMatch];
  const directionPrefix = dir === 'ltr' ? '' : RTL_CLASSNAME + ' ';

  if (axResult !== undefined) {
    return directionPrefix + resultClassName + axResult;
  }

  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line prefer-spread
  const resultDefinitions: MakeStylesMatchedDefinitions = Object.assign.apply<MakeStylesMatchedDefinitions[]>(
    Object,
    // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
    [{}].concat(sequenceMappings),
  );

  let atomicClassNames = '';

  // eslint-disable-next-line guard-for-in
  for (const property in resultDefinitions) {
    atomicClassNames += resultDefinitions[property][0] + ' ';
  }

  atomicClassNames = atomicClassNames.slice(0, -1);

  // Each merge of classes generates a new sequence of atomic classes that needs to be registered
  const newSequenceHash = SEQUENCE_PREFIX + hashString(atomicClassNames);
  atomicClassNames = newSequenceHash + ' ' + atomicClassNames;

  axResults[sequenceMatch] = atomicClassNames;
  DEFINITION_LOOKUP_TABLE[newSequenceHash] = resultDefinitions;

  return directionPrefix + resultClassName + atomicClassNames;
}
